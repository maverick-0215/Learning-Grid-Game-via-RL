<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gridworld Reinforcement Learning Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Top Navigation Bar */
        .navbar {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 2px solid #0f3460;
        }

        .navbar-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
        }

        .navbar-title {
            padding: 20px 0;
        }

        .navbar h1 {
            color: white;
            font-size: 1.9em;
            font-weight: 600;
            letter-spacing: 1px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .navbar-links {
            display: flex;
            gap: 0;
        }

        .navbar-links a {
            color: white;
            text-decoration: none;
            padding: 25px 24px;
            font-size: 0.98em;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            letter-spacing: 0.3px;
        }

        .navbar-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            border-bottom-color: #4a90e2;
            transform: translateY(-2px);
        }

        .github-link {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .github-icon {
            width: 20px;
            height: 20px;
            fill: white;
            transition: transform 0.3s ease;
        }

        .github-link:hover .github-icon {
            transform: rotate(360deg);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 50px;
            min-height: calc(100vh - 200px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 10px;
            font-size: 2em;
            font-weight: 600;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1em;
            font-style: italic;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 35px;
            margin-top: 40px;
        }

        .panel {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
        }

        .panel:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }

        .panel h2 {
            color: #1a1a2e;
            margin-bottom: 25px;
            font-size: 1.4em;
            border-bottom: 3px solid #1a1a2e;
            padding-bottom: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #444;
            font-size: 1.05em;
            letter-spacing: 0.3px;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 15px;
            transition: all 0.3s ease;
            font-family: 'Times New Roman', Times, serif;
            background: white;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .grid-container {
            display: inline-block;
            margin: 20px auto;
            padding: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .grid {
            display: grid;
            gap: 3px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid #5a67d8;
            margin: 0 auto;
            border-radius: 5px;
            padding: 3px;
            box-shadow: 0 4px 12px rgba(90, 103, 216, 0.3);
        }

        .cell {
            width: 50px;
            height: 50px;
            background: #fff;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            transition: all 0.25s ease;
            position: relative;
            font-family: 'Courier New', monospace;
            border-radius: 3px;
        }

        .cell:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .cell.rock {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .cell.start {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(39, 174, 96, 0.4);
            font-weight: 900;
        }

        .cell.goal {
            background: linear-gradient(135deg, #e67e22 0%, #f39c12 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(230, 126, 34, 0.4);
            font-weight: 900;
        }

        .cell.path {
            background: #3498db;
            animation: pathPulse 0.5s ease;
        }

        @keyframes pathPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .algorithm-selector {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .algorithm-option {
            display: flex;
            align-items: center;
            padding: 15px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .algorithm-option:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-color: #4a90e2;
            transform: translateX(5px);
            box-shadow: 0 3px 10px rgba(74, 144, 226, 0.2);
        }

        .algorithm-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 12px;
        }

        .algorithm-option label {
            cursor: pointer;
            font-weight: 400;
            color: #333;
            margin: 0;
            font-size: 0.95em;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        button {
            flex: 1;
            padding: 14px 28px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-family: 'Times New Roman', Times, serif;
        }

        button.primary {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(26, 26, 46, 0.3);
        }

        button.primary:hover {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            box-shadow: 0 6px 20px rgba(26, 26, 46, 0.4);
        }

        button.primary:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            color: #374151;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        button.secondary:hover {
            background: linear-gradient(135deg, #d1d5db 0%, #c0c5cd 100%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
        }

        button.simulate-btn {
            background: linear-gradient(135deg, #6a4c93 0%, #4a3470 100%);
            color: white;
            box-shadow: 0 3px 10px rgba(106, 76, 147, 0.3);
        }

        button.simulate-btn:hover {
            background: linear-gradient(135deg, #8b6bb8 0%, #6a4c93 100%);
            box-shadow: 0 5px 14px rgba(106, 76, 147, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .results-panel {
            grid-column: 1 / -1;
        }

        #resultsChart {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 20px;
            background: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 25px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            border-left: 5px solid #1a1a2e;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            border-left-color: #4a90e2;
        }

        .stat-card h3 {
            color: #1a1a2e;
            font-size: 0.9em;
            text-transform: uppercase;
            margin-bottom: 12px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .stat-card .value {
            font-size: 2.2em;
            font-weight: 700;
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .legend {
            display: flex;
            gap: 25px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95em;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .legend-item:hover {
            background: white;
            transform: scale(1.05);
        }

        .legend-color {
            width: 32px;
            height: 32px;
            border-radius: 5px;
            border: 2px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.1em;
            color: #1a1a2e;
            font-style: italic;
        }

        .hyperparameters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .hyperparam-input {
            display: flex;
            flex-direction: column;
        }

        .hyperparam-input label {
            font-size: 0.9em;
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }

        .hyperparam-input input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
            font-family: 'Times New Roman', Times, serif;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 46, 0.75);
            backdrop-filter: blur(5px);
            overflow: auto;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            margin: 5% auto;
            padding: 0;
            border: none;
            width: 80%;
            max-width: 900px;
            border-radius: 12px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideDown 0.4s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 25px 35px;
            border-radius: 12px 12px 0 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.6em;
            color: white;
            border: none;
            letter-spacing: 0.5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .modal-body {
            padding: 35px;
            line-height: 1.7;
        }

        .modal-body h3 {
            color: #1a1a2e;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.25em;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 8px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .modal-body p, .modal-body li {
            line-height: 1.9;
            color: #444;
            margin-bottom: 10px;
        }

        .modal-body ul {
            margin-left: 30px;
            margin-top: 12px;
        }

        .modal-body ol {
            margin-left: 30px;
            margin-top: 12px;
        }

        .modal-body ul li, .modal-body ol li {
            margin-bottom: 8px;
            padding-left: 5px;
        }

        .close {
            color: white;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
            transition: all 0.3s ease;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .equation {
            background: linear-gradient(135deg, #f9f9f9 0%, #ffffff 100%);
            padding: 18px 20px;
            margin: 18px 0;
            border-left: 5px solid #4a90e2;
            font-family: 'Courier New', monospace;
            font-size: 1.05em;
            overflow-x: auto;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .algorithm-description {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(74, 144, 226, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(74, 144, 226, 0.2);
        }

        /* Smooth Scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Loading Animation */
        #loadingMessage {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.02);
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #1a1a2e 0%, #4a90e2 100%);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #4a90e2 0%, #667eea 100%);
        }

        /* Footer */
        .footer {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            text-align: center;
            padding: 20px 30px;
            margin-top: 40px;
            border-top: 3px solid #4a90e2;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 0.95em;
            letter-spacing: 0.3px;
        }

        .footer-content strong {
            color: #4a90e2;
            font-weight: 600;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .cell {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }

            .navbar-content {
                flex-direction: column;
                padding: 10px 20px;
            }

            .navbar-links {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }

            .navbar-links a {
                padding: 15px;
            }

            .panel {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="navbar-content">
            <div class="navbar-title">
                <h1>Gridworld Reinforcement Learning Simulator</h1>
            </div>
            <div class="navbar-links">
                <a href="#" onclick="openModal('howToModal'); return false;">User Guide</a>
                <a href="#" onclick="openModal('algoModal'); return false;">Algorithms</a>
                <a href="https://github.com/maverick-0215/Learning-Grid-Game-via-RL" target="_blank" class="github-link">
                    <svg class="github-icon" viewBox="0 0 16 16" version="1.1">
                        <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    GitHub
                </a>
            </div>
        </div>
    </nav>

    <!-- Modals -->
    <div id="howToModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeModal('howToModal')">&times;</span>
                <h2>User Guide</h2>
            </div>
            <div class="modal-body">
                <h3>MDP Formulation</h3>
                <p>The gridworld environment is formalized as a Markov Decision Process (MDP):</p>
                <ul style="margin-bottom: 25px;">
                    <li><strong>State Space (S):</strong> n × n discrete grid positions. For a grid of size n, there are n² possible states.</li>
                    <li><strong>Action Space (A):</strong> Four discrete actions available from any state:
                        <ul style="margin-top: 8px;">
                            <li>↑ Up: Move to cell above (if valid)</li>
                            <li>↓ Down: Move to cell below (if valid)</li>
                            <li>← Left: Move to cell to the left (if valid)</li>
                            <li>→ Right: Move to cell to the right (if valid)</li>
                        </ul>
                    </li>
                    <li><strong>Reward Function (R):</strong> Deterministic rewards based on transitions:
                        <ul style="margin-top: 8px;">
                            <li>+10: Reaching the goal state (terminal)</li>
                            <li>-0.1: Valid movement to an empty cell (encourages efficiency)</li>
                            <li>-1: Collision with obstacle or boundary (agent remains in current state)</li>
                        </ul>
                    </li>
                    <li><strong>Transition Dynamics:</strong> Deterministic. Actions deterministically move the agent unless blocked.</li>
                    <li><strong>Discount Factor (γ):</strong> Configurable, typically 0.9, controls importance of future rewards.</li>
                </ul>

                <h3>Environment Setup</h3>
                <ol>
                    <li><strong>Grid Size:</strong> Enter a value between 3 and 10, then click "Apply Grid Size"</li>
                    <li><strong>Add Obstacles:</strong> Click on grid cells to toggle rocks (obstacles). Start (S) and Goal (G) positions are fixed</li>
                    <li><strong>Legend:</strong>
                        <ul>
                            <li>S (Green): Start position (top-left)</li>
                            <li>G (Orange): Goal position (bottom-right)</li>
                            <li># (Dark): Rock/Obstacle</li>
                            <li>Empty (White): Walkable cell</li>
                        </ul>
                    </li>
                </ol>

                <h3>Algorithm Selection</h3>
                <p>Select one or more algorithms to train and compare. You can choose any combination of:</p>
                <ul>
                    <li><strong>Q-Learning:</strong> Off-policy temporal difference learning</li>
                    <li><strong>SARSA:</strong> On-policy temporal difference learning</li>
                    <li><strong>Monte Carlo:</strong> Episode-based first-visit method</li>
                </ul>

                <h3>Hyperparameters</h3>
                <ul>
                    <li><strong>Learning Rate (α):</strong> Controls step size for value updates. Must be in range (0, 1), typically 0.1. Values at extremes (0 or 1) will prevent learning.</li>
                    <li><strong>Discount Factor (γ):</strong> Determines importance of future rewards versus immediate rewards. Range: [0, 1), typically 0.9. Value of 1 can cause instability.</li>
                    <li><strong>Episodes:</strong> Number of complete training trajectories from start to goal. Range: 100-10000. Typical: 1000-2000.</li>
                </ul>
                <p style="margin-top: 10px; color: #666; font-style: italic;">Note: Exploration rate (ε) is fixed at 0.1 for ε-greedy action selection. Both α and γ cannot be set very high (> 0.95) simultaneously as this causes instability.</p>

                <h3>What Does Convergence Mean?</h3>
                <p>An algorithm is considered <strong>converged</strong> when it meets ALL of the following criteria:</p>
                <ul>
                    <li><strong>Finds the goal:</strong> Successfully reaches the goal state in each episode</li>
                    <li><strong>Near-optimal path:</strong> Path length is within 3 steps of the shortest possible path</li>
                    <li><strong>Stable performance:</strong> Low variance (< 2 steps²) over the last 10 episodes</li>
                    <li><strong>Consistent behavior:</strong> Takes similar paths repeatedly without random exploration</li>
                </ul>
                <p style="margin-top: 10px;">If an algorithm shows "Did not converge", try increasing episodes, adjusting hyperparameters, or simplifying the environment by removing obstacles.</p>

                <h3>Training and Results</h3>
                <ol>
                    <li>After configuring the environment and parameters, click "Train Agents"</li>
                    <li>Wait for training to complete (typically a few seconds depending on grid size and episodes)</li>
                    <li>View the learning curves showing convergence: steps per episode over time</li>
                    <li>Check statistics cards for final performance metrics (average steps, success rate)</li>
                    <li>Click "Simulate Learned Policies" to visualize the optimal paths discovered by each algorithm</li>
                </ol>
            </div>
        </div>
    </div>

    <div id="algoModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeModal('algoModal')">&times;</span>
                <h2>Algorithm Information</h2>
            </div>
            <div class="modal-body">
                <div class="algorithm-description">
                    <h3>Q-Learning (Off-Policy TD)</h3>
                    <p><strong>Type:</strong> Off-policy Temporal Difference learning</p>
                    <p><strong>Update Rule:</strong></p>
                    <div class="equation">
                        Q(s,a) ← Q(s,a) + α[r + γ max<sub>a'</sub> Q(s',a') - Q(s,a)]
                    </div>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li>Learns the optimal action-value function independent of the policy being followed</li>
                        <li>Uses maximum Q-value of next state (optimistic update)</li>
                        <li>Converges to optimal policy even with exploratory behavior</li>
                        <li>Typically finds shorter paths but may take risks</li>
                    </ul>
                </div>

                <div class="algorithm-description">
                    <h3>SARSA (On-Policy TD)</h3>
                    <p><strong>Type:</strong> On-policy Temporal Difference learning</p>
                    <p><strong>Update Rule:</strong></p>
                    <div class="equation">
                        Q(s,a) ← Q(s,a) + α[r + γ Q(s',a') - Q(s,a)]
                    </div>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li>Learns the value of the policy being followed (including exploration)</li>
                        <li>Uses actual next action from ε-greedy policy</li>
                        <li>More conservative than Q-Learning</li>
                        <li>Takes exploration into account when learning</li>
                        <li>Often chooses safer paths avoiding obstacles</li>
                    </ul>
                </div>

                <div class="algorithm-description">
                    <h3>Monte Carlo (First-Visit)</h3>
                    <p><strong>Type:</strong> Episode-based method</p>
                    <p><strong>Update Rule:</strong></p>
                    <div class="equation">
                        Q(s,a) ← Q(s,a) + α[G<sub>t</sub> - Q(s,a)]
                    </div>
                    <p>Where G<sub>t</sub> is the return (sum of discounted rewards) from time t until episode end.</p>
                    <p><strong>Characteristics:</strong></p>
                    <ul>
                        <li>Learns from complete episodes (no bootstrapping)</li>
                        <li>Updates only after episode completion</li>
                        <li>Uses actual returns G<sub>t</sub> = R<sub>t+1</sub> + γR<sub>t+2</sub> + γ²R<sub>t+3</sub> + ...</li>
                        <li>Unbiased estimate of true value function</li>
                        <li>May require more episodes to converge but stable</li>
                    </ul>
                </div>

                <h3>Key Differences</h3>
                <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <tr style="background: #f0f0f0;">
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Aspect</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Q-Learning</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">SARSA</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Monte Carlo</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Policy</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Off-policy</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">On-policy</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">On-policy</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Update</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Every step</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Every step</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">End of episode</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Bootstrap</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Yes</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Yes</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">No</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Convergence</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Fast</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Fast</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Slower</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-content">
            <!-- Setup Panel -->
            <div class="panel">
                <h2>Environment Setup</h2>
                
                <div class="control-group">
                    <label for="gridSize">Grid Size (3-10)</label>
                    <input type="number" id="gridSize" min="3" max="10" value="5">
                    <button class="secondary" style="margin-top: 10px;" onclick="createGrid()">Apply Grid Size</button>
                </div>

                <div class="control-group">
                    <label>Grid Editor</label>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #27ae60;"></div>
                            <span>Start (S)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #e67e22;"></div>
                            <span>Goal (G)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2c3e50;"></div>
                            <span>Rock (#)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: white; border: 1px solid #999;"></div>
                            <span>Empty</span>
                        </div>
                    </div>
                    <div class="grid-container">
                        <div id="grid" class="grid"></div>
                    </div>
                    <p style="margin-top: 10px; color: #666; font-size: 0.85em;">Click cells to toggle rocks. Start and goal positions are fixed.</p>
                </div>
            </div>

            <!-- Algorithm Panel -->
            <div class="panel">
                <h2>Algorithm Selection</h2>
                
                <div class="control-group">
                    <label>Choose Algorithms to Compare</label>
                    <div class="algorithm-selector">
                        <div class="algorithm-option">
                            <input type="checkbox" id="algoQ" value="qlearning" checked>
                            <label for="algoQ">Q-Learning (Off-Policy TD)</label>
                        </div>
                        <div class="algorithm-option">
                            <input type="checkbox" id="algoSarsa" value="sarsa" checked>
                            <label for="algoSarsa">SARSA (On-Policy TD)</label>
                        </div>
                        <div class="algorithm-option">
                            <input type="checkbox" id="algoMC" value="montecarlo" checked>
                            <label for="algoMC">Monte Carlo (First-Visit)</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Hyperparameters</label>
                    <div class="hyperparameters">
                        <div class="hyperparam-input">
                            <label for="alpha">Learning Rate (α)</label>
                            <input type="number" id="alpha" min="0" max="1" step="0.01" value="0.1">
                        </div>
                        <div class="hyperparam-input">
                            <label for="gamma">Discount Factor (γ)</label>
                            <input type="number" id="gamma" min="0" max="1" step="0.01" value="0.9">
                        </div>
                        <div class="hyperparam-input">
                            <label for="episodes">Episodes</label>
                            <input type="number" id="episodes" min="100" max="10000" step="100" value="1000">
                        </div>
                    </div>
                    <p style="margin-top: 10px; color: #666; font-size: 0.85em; font-style: italic;">
                        Exploration rate (ε) is set to 0.1 for optimal balance.
                    </p>
                </div>

                <div class="button-group">
                    <button class="primary" onclick="trainAlgorithms()">Train Agents</button>
                    <button class="secondary" onclick="resetEnvironment()">Reset Environment</button>
                </div>
                
                <div class="button-group" style="margin-top: 15px;">
                    <button class="simulate-btn" onclick="simulateBestPath()">Simulate Learned Policies</button>
                </div>
            </div>

            <!-- Results Panel -->
            <div class="panel results-panel">
                <h2>Training Results</h2>
                <div id="loadingMessage" class="loading" style="display: none;">
                    Training in progress...
                </div>
                <canvas id="resultsChart"></canvas>
                <div id="stats" class="stats"></div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <span><strong>CS329</strong> Foundations of AI - Course Project</span>
        </div>
    </footer>

    <script>
        // ====== GLOBAL STATE ======
        let gridSize = 5;
        let grid = [];
        let start = [0, 0];
        let goal = [4, 4];
        let rocks = new Set();
        let trainingResults = {};
        let isSimulating = false;
        let simulationInterval = null;

        const actions = [
            [-1, 0],  // up
            [1, 0],   // down
            [0, -1],  // left
            [0, 1]    // right
        ];

        // ====== GRID MANAGEMENT ======
        function createGrid() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            if (gridSize < 3) gridSize = 3;
            if (gridSize > 10) gridSize = 10;
            
            start = [0, 0];
            goal = [gridSize - 1, gridSize - 1];
            rocks.clear();
            
            // Create grid array
            grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            
            renderGrid();
        }

        function renderGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 50px)`;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.id = `cell-${i}-${j}`;
                    
                    const key = `${i},${j}`;
                    
                    if (i === start[0] && j === start[1]) {
                        cell.classList.add('start');
                        cell.textContent = 'S';
                    } else if (i === goal[0] && j === goal[1]) {
                        cell.classList.add('goal');
                        cell.textContent = 'G';
                    } else if (rocks.has(key)) {
                        cell.classList.add('rock');
                        cell.textContent = '#';
                        grid[i][j] = 1;
                    } else {
                        grid[i][j] = 0;
                    }
                    
                    cell.addEventListener('click', () => toggleRock(i, j));
                    gridElement.appendChild(cell);
                }
            }
        }

        function toggleRock(row, col) {
            // Don't allow toggling start or goal
            if ((row === start[0] && col === start[1]) || 
                (row === goal[0] && col === goal[1])) {
                return;
            }
            
            const key = `${row},${col}`;
            if (rocks.has(key)) {
                rocks.delete(key);
            } else {
                rocks.add(key);
            }
            renderGrid();
        }

        // ====== ENVIRONMENT ======
        class GridEnvironment {
            constructor(gridSize, rocks, start, goal) {
                this.gridSize = gridSize;
                this.rocks = rocks;
                this.start = start;
                this.goal = goal;
                this.reset();
            }

            reset() {
                this.pos = [...this.start];
                return this.pos;
            }

            step(action) {
                const move = actions[action];
                const newPos = [this.pos[0] + move[0], this.pos[1] + move[1]];
                
                // Out of bounds
                if (newPos[0] < 0 || newPos[0] >= this.gridSize || 
                    newPos[1] < 0 || newPos[1] >= this.gridSize) {
                    return { nextState: this.pos, reward: -1, done: false };
                }
                
                // Rock
                const key = `${newPos[0]},${newPos[1]}`;
                if (this.rocks.has(key)) {
                    return { nextState: this.pos, reward: -1, done: false };
                }
                
                // Valid move
                this.pos = newPos;
                
                // Check goal
                if (this.pos[0] === this.goal[0] && this.pos[1] === this.goal[1]) {
                    return { nextState: this.pos, reward: 10, done: true };
                }
                
                return { nextState: this.pos, reward: -0.1, done: false };
            }

            stateKey(state) {
                return `${state[0]},${state[1]}`;
            }
        }

        // ====== RL UTILITIES ======
        function initQ(gridSize) {
            const Q = {};
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    Q[`${i},${j}`] = [0, 0, 0, 0];
                }
            }
            return Q;
        }

        function epsGreedy(Q, state, epsilon) {
            if (Math.random() < epsilon) {
                return Math.floor(Math.random() * 4);
            }
            const stateKey = typeof state === 'string' ? state : `${state[0]},${state[1]}`;
            const values = Q[stateKey];
            return values.indexOf(Math.max(...values));
        }

        // ====== PATH SIMULATION ======
        function simulateBestPath() {
            if (Object.keys(trainingResults).length === 0) {
                alert('Please train algorithms first before simulating paths.');
                return;
            }

            // Stop any ongoing simulation
            if (isSimulating) {
                stopSimulation();
                return;
            }

            // Find the first converged algorithm and its best path
            let bestAlgo = null;
            
            for (const [algoName, data] of Object.entries(trainingResults)) {
                const path = extractPolicy(data.Q);
                if (path.reachedGoal) {
                    // Calculate convergence episode (when steps stabilized)
                    const convergenceInfo = findConvergenceEpisode(data.stepsPerEpisode, path.steps);
                    
                    // Only show if truly converged
                    if (convergenceInfo.converged) {
                        bestAlgo = { 
                            name: algoName, 
                            path: path.path, 
                            steps: path.steps, 
                            convergenceEpisode: convergenceInfo.episode,
                            avgSteps: convergenceInfo.avgSteps
                        };
                        break; // Just take the first converged algorithm
                    }
                }
            }

            if (!bestAlgo) {
                alert('None of the algorithms have converged to an optimal solution yet.\n\nConvergence requires:\n- Reaching the goal consistently\n- Path length near optimal (shortest path)\n- Stable performance over last 10 episodes\n\nTry:\n- Increasing episodes\n- Adjusting hyperparameters\n- Simplifying the environment');
                return;
            }

            // Show path for the converged algorithm
            displayPathSimulation(bestAlgo);
        }

        function findConvergenceEpisode(stepsPerEpisode, optimalPathLength) {
            // Convergence criteria: path length is stable and near optimal for last 10 episodes
            const windowSize = 10;
            const varianceThreshold = 2; // Very low variance required
            
            // If optimal path length is unreasonably high, it's not converged
            if (optimalPathLength >= 100) {
                return { 
                    converged: false, 
                    episode: null, 
                    avgSteps: 0
                };
            }
            
            const optimalThreshold = optimalPathLength + 3; // Within 3 steps of optimal
            
            // Check if last 10 episodes are converged
            if (stepsPerEpisode.length >= windowSize) {
                const lastWindow = stepsPerEpisode.slice(-windowSize);
                const avg = lastWindow.reduce((a, b) => a + b, 0) / windowSize;
                const variance = lastWindow.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / windowSize;
                
                // Check if converged: low variance AND near optimal path length
                if (variance < varianceThreshold && avg <= optimalThreshold) {
                    // Find when it first converged
                    for (let i = windowSize; i < stepsPerEpisode.length; i++) {
                        const window = stepsPerEpisode.slice(i - windowSize, i);
                        const windowAvg = window.reduce((a, b) => a + b, 0) / windowSize;
                        const windowVar = window.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / windowSize;
                        
                        if (windowVar < varianceThreshold && windowAvg <= optimalThreshold) {
                            return { 
                                converged: true, 
                                episode: i, 
                                avgSteps: Math.round(windowAvg * 10) / 10 
                            };
                        }
                    }
                    // If we reach here, it converged but only in the last episodes
                    return { 
                        converged: true, 
                        episode: stepsPerEpisode.length, 
                        avgSteps: Math.round(avg * 10) / 10 
                    };
                }
            }
            
            // Not converged
            return { 
                converged: false, 
                episode: null, 
                avgSteps: 0
            };
        }

        function extractPolicy(Q) {
            const maxSteps = 200;
            const path = [];
            let currentPos = [...start];
            path.push([...currentPos]);

            for (let step = 0; step < maxSteps; step++) {
                const stateKey = `${currentPos[0]},${currentPos[1]}`;
                const qValues = Q[stateKey];
                const action = qValues.indexOf(Math.max(...qValues));
                
                // Take action
                const move = actions[action];
                const newPos = [currentPos[0] + move[0], currentPos[1] + move[1]];
                
                // Check bounds
                if (newPos[0] < 0 || newPos[0] >= gridSize || newPos[1] < 0 || newPos[1] >= gridSize) {
                    break;
                }
                
                // Check rock
                const key = `${newPos[0]},${newPos[1]}`;
                if (rocks.has(key)) {
                    break;
                }
                
                currentPos = newPos;
                path.push([...currentPos]);
                
                // Check if reached goal
                if (currentPos[0] === goal[0] && currentPos[1] === goal[1]) {
                    return { path, reachedGoal: true, steps: path.length };
                }
            }
            
            return { path, reachedGoal: false, steps: path.length };
        }

        function displayPathSimulation(algoData) {
            // Reset grid
            renderGrid();
            
            // Animate path directly without popup
            isSimulating = true;
            animatePath(algoData);
        }

        function animatePath(algoData) {
            const colors = {
                'Q-Learning': '#3b82f6',
                'SARSA': '#10b981',
                'Monte Carlo': '#f59e0b'
            };
            
            const color = colors[algoData.name];
            const path = algoData.path;
            let currentStep = 0;
            
            simulationInterval = setInterval(() => {
                if (currentStep >= path.length || !isSimulating) {
                    clearInterval(simulationInterval);
                    return;
                }
                
                const [row, col] = path[currentStep];
                const cellId = `cell-${row}-${col}`;
                const cell = document.getElementById(cellId);
                
                if (cell && !cell.classList.contains('start') && !cell.classList.contains('goal')) {
                    cell.style.background = color;
                    cell.style.opacity = '0.8';
                }
                
                currentStep++;
            }, 200); // Animate every 200ms
        }

        function stopSimulation() {
            isSimulating = false;
            if (simulationInterval) {
                clearInterval(simulationInterval);
            }
            
            renderGrid();
        }

        // ====== Q-LEARNING ======
        function qLearning(env, alpha, gamma, epsilon, episodes) {
            const Q = initQ(env.gridSize);
            const stepsPerEpisode = [];
            
            for (let ep = 0; ep < episodes; ep++) {
                let state = env.reset();
                let done = false;
                let steps = 0;
                
                while (!done && steps < 200) {
                    const stateKey = env.stateKey(state);
                    const action = epsGreedy(Q, stateKey, epsilon);
                    const { nextState, reward, done: isDone } = env.step(action);
                    done = isDone;
                    
                    const nextKey = env.stateKey(nextState);
                    const bestNext = Math.max(...Q[nextKey]);
                    Q[stateKey][action] += alpha * (reward + gamma * bestNext - Q[stateKey][action]);
                    
                    state = nextState;
                    steps++;
                }
                
                stepsPerEpisode.push(steps);
            }
            
            return { Q, stepsPerEpisode };
        }

        // ====== SARSA ======
        function sarsa(env, alpha, gamma, epsilon, episodes) {
            const Q = initQ(env.gridSize);
            const stepsPerEpisode = [];
            
            for (let ep = 0; ep < episodes; ep++) {
                let state = env.reset();
                let stateKey = env.stateKey(state);
                let action = epsGreedy(Q, stateKey, epsilon);
                let done = false;
                let steps = 0;
                
                while (!done && steps < 200) {
                    const { nextState, reward, done: isDone } = env.step(action);
                    done = isDone;
                    
                    const nextKey = env.stateKey(nextState);
                    const nextAction = epsGreedy(Q, nextKey, epsilon);
                    
                    Q[stateKey][action] += alpha * (reward + gamma * Q[nextKey][nextAction] - Q[stateKey][action]);
                    
                    state = nextState;
                    stateKey = nextKey;
                    action = nextAction;
                    steps++;
                }
                
                stepsPerEpisode.push(steps);
            }
            
            return { Q, stepsPerEpisode };
        }

        // ====== MONTE CARLO ======
        function monteCarlo(env, alpha, gamma, epsilon, episodes) {
            const Q = initQ(env.gridSize);
            const returnsSum = {};
            const returnsCount = {};
            const stepsPerEpisode = [];
            
            for (let ep = 0; ep < episodes; ep++) {
                // Generate episode
                let state = env.reset();
                const episode = [];
                let done = false;
                let steps = 0;
                
                while (!done && steps <= 200) {
                    const stateKey = env.stateKey(state);
                    const action = epsGreedy(Q, stateKey, epsilon);
                    const { nextState, reward, done: isDone } = env.step(action);
                    
                    episode.push({ state: stateKey, action, reward });
                    state = nextState;
                    done = isDone;
                    steps++;
                }
                
                stepsPerEpisode.push(steps);
                
                // Compute returns (first-visit)
                let G = 0;
                const visited = new Set();
                
                for (let t = episode.length - 1; t >= 0; t--) {
                    const { state: s, action: a, reward: r } = episode[t];
                    G = gamma * G + r;
                    
                    const saKey = `${s},${a}`;
                    if (!visited.has(saKey)) {
                        visited.add(saKey);
                        
                        if (alpha === null) {
                            // Sample average
                            returnsSum[saKey] = (returnsSum[saKey] || 0) + G;
                            returnsCount[saKey] = (returnsCount[saKey] || 0) + 1;
                            Q[s][a] = returnsSum[saKey] / returnsCount[saKey];
                        } else {
                            // Incremental update
                            Q[s][a] += alpha * (G - Q[s][a]);
                        }
                    }
                }
            }
            
            return { Q, stepsPerEpisode };
        }

        // ====== TRAINING ======
        async function trainAlgorithms() {
            const selectedAlgorithms = [];
            if (document.getElementById('algoQ').checked) selectedAlgorithms.push('qlearning');
            if (document.getElementById('algoSarsa').checked) selectedAlgorithms.push('sarsa');
            if (document.getElementById('algoMC').checked) selectedAlgorithms.push('montecarlo');
            
            if (selectedAlgorithms.length === 0) {
                alert('Please select at least one algorithm!');
                return;
            }
            
            // Get hyperparameters
            const alpha = parseFloat(document.getElementById('alpha').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            const epsilon = 0.1; // Fixed exploration rate for optimal balance
            const episodes = parseInt(document.getElementById('episodes').value);
            
            // Validate hyperparameters
            if (alpha <= 0 || alpha >= 1) {
                alert('Learning Rate (α) must be between 0 and 1 (exclusive).\nTypical value: 0.1');
                return;
            }
            if (gamma < 0 || gamma >= 1) {
                alert('Discount Factor (γ) must be between 0 and 1 (exclusive for 1).\nTypical value: 0.9');
                return;
            }
            if (alpha > 0.95 && gamma > 0.95) {
                alert('Both Learning Rate and Discount Factor cannot be very high (> 0.95) simultaneously.\nThis causes training instability.');
                return;
            }
            
            // Show loading
            document.getElementById('loadingMessage').style.display = 'block';
            document.getElementById('stats').innerHTML = '';
            
            trainingResults = {};
            
            // Create environment
            const env = new GridEnvironment(gridSize, rocks, start, goal);
            
            // Train each selected algorithm
            await new Promise(resolve => setTimeout(resolve, 100)); // Allow UI to update
            
            for (const algo of selectedAlgorithms) {
                let result;
                
                switch (algo) {
                    case 'qlearning':
                        result = qLearning(env, alpha, gamma, epsilon, episodes);
                        trainingResults['Q-Learning'] = result;
                        break;
                    case 'sarsa':
                        result = sarsa(env, alpha, gamma, epsilon, episodes);
                        trainingResults['SARSA'] = result;
                        break;
                    case 'montecarlo':
                        result = monteCarlo(env, null, gamma, epsilon, episodes);
                        trainingResults['Monte Carlo'] = result;
                        break;
                }
            }
            
            // Hide loading
            document.getElementById('loadingMessage').style.display = 'none';
            
            // Display results
            displayResults();
        }

        // ====== VISUALIZATION ======
        function displayResults() {
            const canvas = document.getElementById('resultsChart');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = 400;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Find max episodes and max steps
            let maxEpisodes = 0;
            let maxSteps = 0;
            
            for (const [name, data] of Object.entries(trainingResults)) {
                maxEpisodes = Math.max(maxEpisodes, data.stepsPerEpisode.length);
                maxSteps = Math.max(maxSteps, ...data.stepsPerEpisode);
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Episodes', width / 2, height - 20);
            
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Steps per Episode', 0, 0);
            ctx.restore();
            
            // Draw grid lines
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (height - 2 * padding) * i / 5;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
                
                // Y-axis labels
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                const value = Math.round(maxSteps * (1 - i / 5));
                ctx.fillText(value.toString(), padding - 10, y + 4);
            }
            
            // Draw data
            const colors = {
                'Q-Learning': '#3b82f6',
                'SARSA': '#10b981',
                'Monte Carlo': '#f59e0b'
            };
            
            for (const [name, data] of Object.entries(trainingResults)) {
                ctx.strokeStyle = colors[name];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const steps = data.stepsPerEpisode;
                for (let i = 0; i < steps.length; i++) {
                    const x = padding + (width - 2 * padding) * i / maxEpisodes;
                    const y = height - padding - (height - 2 * padding) * steps[i] / maxSteps;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            // Draw legend
            let legendY = padding + 20;
            for (const [name, data] of Object.entries(trainingResults)) {
                ctx.fillStyle = colors[name];
                ctx.fillRect(width - padding - 150, legendY - 8, 20, 3);
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(name, width - padding - 125, legendY);
                legendY += 25;
            }
            
            // Display stats
            displayStats();
        }

        function displayStats() {
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = '';
            
            for (const [name, data] of Object.entries(trainingResults)) {
                const steps = data.stepsPerEpisode;
                
                // Run a test episode using the learned policy (greedy, no exploration)
                const env = new GridEnvironment(gridSize, rocks, start, goal);
                let testState = env.reset();
                let testSteps = 0;
                let testDone = false;
                const maxTestSteps = 200;
                
                while (!testDone && testSteps < maxTestSteps) {
                    const stateKey = env.stateKey(testState);
                    const qValues = data.Q[stateKey];
                    const action = qValues.indexOf(Math.max(...qValues)); // Greedy action
                    const { nextState, done } = env.step(action);
                    testState = nextState;
                    testDone = done;
                    testSteps++;
                }
                
                // Extract policy to get optimal path length
                const path = extractPolicy(data.Q);
                
                // If path doesn't reach goal or is too long, it's not converged
                const optimalPathLength = (path.reachedGoal && path.steps < 195) ? path.steps : 999;
                
                // Calculate convergence with optimal path length
                const convergenceInfo = findConvergenceEpisode(steps, optimalPathLength);
                
                const card = document.createElement('div');
                card.className = 'stat-card';
                
                let convergenceText = '';
                if (convergenceInfo.converged) {
                    convergenceText = `<p style="color: #10b981; margin-top: 8px; font-size: 0.9em; font-weight: 600;">✓ Converged at Episode: ${convergenceInfo.episode}</p>`;
                } else {
                    convergenceText = `<p style="color: #ef4444; margin-top: 8px; font-size: 0.9em; font-weight: 600;">✗ Did not converge with current settings</p>`;
                }
                
                // Display test episode steps (greedy policy)
                const testResultText = testDone ? testSteps : '200+ (Failed)';
                
                card.innerHTML = `
                    <h3>${name}</h3>
                    <div class="value">${testResultText}</div>
                    <p style="color: #666; margin-top: 8px;">Test Episode Steps (Greedy Policy)</p>
                    <p style="color: #666; margin-top: 4px; font-size: 0.9em;">Optimal Path: ${path.reachedGoal ? path.steps + ' steps' : 'No path found'}</p>
                    ${convergenceText}
                `;
                statsDiv.appendChild(card);
            }
        }

        function resetEnvironment() {
            trainingResults = {};
            document.getElementById('resultsChart').getContext('2d').clearRect(0, 0, 1000, 400);
            document.getElementById('stats').innerHTML = '';
            createGrid();
        }

        // Modal functions
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }

        // Initialize
        createGrid();
    </script>
</body>
</html>
